'''
1. Подсчитать, сколько было выделено памяти под переменные в ранее разработанных программах в рамках первых трех уроков.
Проанализировать результат и определить программы с наиболее эффективным использованием памяти.
Примечание: По аналогии с эмпирической оценкой алгоритмов идеальным решением будет:
a. выбрать хорошую задачу, которую имеет смысл оценивать по памяти;
b. написать 3 варианта кода (один у вас уже есть); проанализировать 3 варианта и выбрать оптимальный;
c. результаты анализа (количество занятой памяти в вашей среде разработки) вставить в виде комментариев в файл с кодом.
Не забудьте указать версию и разрядность вашей ОС и интерпретатора Python;

d. написать общий вывод: какой из трёх вариантов лучше и почему.

ЗАДАЧА:
В диапазоне натуральных чисел от 2 до 99 определить, сколько из них кратны каждому из чисел в диапазоне от 2 до 9.
Примечание: 8 разных ответов.

Версия: Linux Ubuntu
Разрядность: 64bit

'''


import sys

def count_for(max_number):
    two, three, four, five, six, seven, eight, nine = (0,) * 8
    for i in range(2, max_number + 1):
        if i % 2 == 0:
            two += 1
        if i % 3 == 0:
            three += 1
        if i % 4 == 0:
            four += 1
        if i % 5 == 0:
            five += 1
        if i % 6 == 0:
            six += 1
        if i % 7 == 0:
            seven += 1
        if i % 8 == 0:
            eight += 1
        if i % 9 == 0:
            nine += 1
    return two, three, four, five, six, seven, eight, nine

def count_while(max_number):
    two, three, four, five, six, seven, eight, nine = (0,) * 8
    i = 2
    while i < max_number + 1:
        if i % 2 == 0:
            two += 1
        if i % 3 == 0:
            three += 1
        if i % 4 == 0:
            four += 1
        if i % 5 == 0:
            five += 1
        if i % 6 == 0:
            six += 1
        if i % 7 == 0:
            seven += 1
        if i % 8 == 0:
            eight += 1
        if i % 9 == 0:
            nine += 1
        i += 1
    return two, three, four, five, six, seven, eight, nine

def count_for_dict(max_number):
    min_num = 2
    max_num = 9
    data_num = dict()
    for item in range(min_num, max_num + 1):
        data_num[item] = max_number // item
    return data_num

def show_size(x, level=0):
    print('\t' * level, f'type = {x.__class__}, size = {sys.getsizeof(x)}, object = {x}')

    if hasattr(x, '__iter__'):
        if hasattr(x, 'items'):
            for xx in x.items():
                show_size(xx, level + 1)
        elif not isinstance(x, str):
            for xx in x:
                show_size(xx, level + 1)

show_size(count_for(99))
print('-' * 100)
show_size(count_while(99))
print('-' * 100)
show_size(count_for_dict(99))

# Вариант 1: type = <class 'tuple'>, size = 104, object = (49, 33, 24, 19, 16, 14, 12, 11)
# Вариант 2: type = <class 'tuple'>, size = 104, object = (49, 33, 24, 19, 16, 14, 12, 11)
# Вариант 3: type = <class 'dict'>, size = 360, object = {2: 49, 3: 33, 4: 24, 5: 19, 6: 16, 7: 14, 8: 12, 9: 11}

'''
ВЫВОДЫ

Первый и второй варианты по сути делают одно и то же и в результат получается одинаковый (со скоростью так же вышло).
Результат один, объект формируется одного типа => размер одинаковый

Третий вариант, самый быстрый и красивый (на мой взгляд), хотя  и занимает в три с половиной раза больше памяти. 
Очевидно из-за того, что данные храняться в словае. То есть к каждому значению в памяти хранится и ключ.

С учетом быстродействия я бы предпочел третий вариант в любом случае. Потому что затрачиваемая память во всех 
вариантах находится в одном порядке (сотни). Для данной задачи разница в три раза считаю несущественной.

'''